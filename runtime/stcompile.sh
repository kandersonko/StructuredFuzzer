#!/bin/bash

# Portable Compile Script for Fuzzer
# This script orchestrates code analysis and fuzzer compilation

set -e  # Exit on any error

# Configuration - can be overridden by environment variables
AFL_DICT_FILE="${AFL_DICT_FILE:-inputs.dict}"
ENABLE_CODE_ANALYSIS="${ENABLE_CODE_ANALYSIS:-true}"

# Configuration - these can be overridden by environment variables
CC="${CC:-afl-clang-fast}"
FALLBACK_CC="${FALLBACK_CC:-clang}"
IEC2C="${IEC2C:-iec2c}"
CFLAGS="${CFLAGS:--std=gnu99 -w}"
LDFLAGS="${LDFLAGS:--lrt}"

# Required source files (should be in same directory as script or provided paths)
REQUIRED_DIR="/usr/local/bin/stfuzz/runtime"
# These are the C source filenames that need to be compiled
REQUIRED_SOURCE_FILES=("main.c" "plc.c")
# These are header files that need to be copied but not compiled
REQUIRED_HEADER_FILES=("inputs.h")
# These are generated by iec2c and need to be compiled
GENERATED_FILES=("STD_CONF.c" "STD_RESSOURCE.c")

# Default harness file
HARNESS_FILE="harness.c"
# Default output directory
OUTPUT_DIR="build/"
# Default corpus directory
CORPUS_DIR="corpus/"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_debug() {
    if [ "${DEBUG:-false}" = "true" ]; then
        echo -e "${BLUE}[DEBUG]${NC} $1"
    fi
}

# Function to check if a command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to display usage
usage() {
    cat << EOF
Usage: $0 <st_file> <harness_file> [options]

Arguments:
    st_file         Path to the structured text (.st) file
    harness_file    Path to the fuzzing harness (.c) file

Options:
    -o, --output DIR        Output directory (default: build/ in current directory)
    -n, --name NAME         Executable name (default: derived from st_file filename)
    -c, --corpus DIR        Corpus directory (default: corpus/ in current directory)
    --no-analysis           Skip code analysis step
    --dict-file FILE        AFL dictionary filename (default: $AFL_DICT_FILE)
    --debug                 Enable debug output
    --help                  Show this help message

Environment Variables:
    AFL_DICT_FILE           AFL dictionary filename
    ENABLE_CODE_ANALYSIS    Enable/disable code analysis (true/false)
    DEBUG                   Enable debug output (true/false)
    CC                  C compiler to use
    FALLBACK_CC         Fallback compiler if CC is not available
    IEC2C               IEC compiler to use
    CFLAGS              Additional C compiler flags
    LDFLAGS             Additional linker flags
    MATIEC_C_INCLUDE_PATH   MatIEC C include path
    MATIEC_INCLUDE_PATH     MatIEC include path
    EXECUTABLE_NAME     Default executable name

Examples:
    $0 program.st harness.c
    $0 program.st harness.c -o build/ -n executable_name
    $0 program.st harness.c --no-analysis
EOF
}

# Function to parse command line arguments
parse_args() {
    if [ $# -lt 2 ]; then
        log_error "Insufficient arguments"
        usage
        exit 1
    fi

    ST_FILE=""
    HARNESS_FILE=""
    OUTPUT_DIR="build/"
    EXECUTABLE_NAME=""
    CORPUS_DIR="corpus/"

    while [[ $# -gt 0 ]]; do
        case $1 in
            --help)
                usage
                exit 0
                ;;
            -o|--output)
                OUTPUT_DIR="$2"
                shift 2
                ;;
            -n|--name)
                EXECUTABLE_NAME="$2"
                shift 2
                ;;
            -c|--corpus)
                CORPUS_DIR="$2"
                shift 2
                ;;
            --no-analysis)
                ENABLE_CODE_ANALYSIS="false"
                shift
                ;;
            --dict-file)
                AFL_DICT_FILE="$2"
                shift 2
                ;;
            --debug)
                DEBUG="true"
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                usage
                exit 1
                ;;
            *)
                if [ -z "$ST_FILE" ]; then
                    ST_FILE="$1"
                elif [ -z "$HARNESS_FILE" ]; then
                    HARNESS_FILE="$1"
                else
                    log_error "Too many positional arguments"
                    usage
                    exit 1
                fi
                shift
                ;;
        esac
    done

    # Validate required arguments
    if [ -z "$ST_FILE" ] || [ -z "$HARNESS_FILE" ]; then
        log_error "Both ST file and harness file must be specified"
        usage
        exit 1
    fi

    # Convert to absolute paths and validate
    if [ ! -f "$ST_FILE" ]; then
        log_error "ST file not found: $ST_FILE"
        exit 1
    fi
    ST_FILE="$(realpath "$ST_FILE")"

    if [ ! -f "$HARNESS_FILE" ]; then
        log_error "Harness file not found: $HARNESS_FILE"
        exit 1
    fi
    HARNESS_FILE="$(realpath "$HARNESS_FILE")"

    # Set executable name default based on ST file if not provided
    if [ -z "$EXECUTABLE_NAME" ]; then
        EXECUTABLE_NAME="$(basename "$ST_FILE" .st)"
    fi

    # Ensure output and corpus directories exist
    mkdir -p "$OUTPUT_DIR"
    mkdir -p "$CORPUS_DIR"
    OUTPUT_DIR="$(realpath "$OUTPUT_DIR")"
    CORPUS_DIR="$(realpath "$CORPUS_DIR")"
}

check_dependencies() {
    log_info "Checking dependencies..."

    local missing_deps=()

    # Check for compiler
    if ! command_exists "$CC"; then
        log_warn "Compiler '$CC' not found"
        if command_exists "$FALLBACK_CC"; then
            log_info "Using fallback compiler '$FALLBACK_CC'"
            CC="$FALLBACK_CC"
        else
            missing_deps+=("$CC or $FALLBACK_CC")
        fi
    fi

    # Check for IEC compiler
    if ! command_exists "$IEC2C"; then
        missing_deps+=("$IEC2C")
    fi

    # Check for required environment variables
    if [ -z "$MATIEC_C_INCLUDE_PATH" ]; then
        log_warn "MATIEC_C_INCLUDE_PATH not set"
        # Try to find it in common locations
        for path in /usr/include/matiec /usr/local/include/matiec /opt/matiec/include; do
            if [ -d "$path" ]; then
                export MATIEC_C_INCLUDE_PATH="$path"
                log_info "Found MatIEC C includes at: $MATIEC_C_INCLUDE_PATH"
                break
            fi
        done

        if [ -z "$MATIEC_C_INCLUDE_PATH" ]; then
            log_error "MATIEC_C_INCLUDE_PATH must be set"
            missing_deps+=("MATIEC_C_INCLUDE_PATH environment variable")
        fi
    fi

    if [ -z "$MATIEC_INCLUDE_PATH" ]; then
        log_warn "MATIEC_INCLUDE_PATH not set"
        # Try to find it in common locations
        for path in /usr/share/matiec /usr/local/share/matiec /opt/matiec/share; do
            if [ -d "$path" ]; then
                export MATIEC_INCLUDE_PATH="$path"
                log_info "Found MatIEC includes at: $MATIEC_INCLUDE_PATH"
                break
            fi
        done

        if [ -z "$MATIEC_INCLUDE_PATH" ]; then
            log_error "MATIEC_INCLUDE_PATH must be set"
            missing_deps+=("MATIEC_INCLUDE_PATH environment variable")
        fi
    fi

    if [ ${#missing_deps[@]} -ne 0 ]; then
        log_error "Missing dependencies:"
        printf '  - %s\n' "${missing_deps[@]}"
        echo
        echo "Please install missing tools or set required environment variables."
        echo "Run '$0 --help' for more information."
        exit 1
    fi

    log_info "All dependencies found"
}

# Function to run code analysis
run_code_analysis() {
    local st_file="$1"
    local output_dir="$2"
    local corpus_dir="$3"

    if [ "$ENABLE_CODE_ANALYSIS" != "true" ]; then
        log_info "Code analysis disabled, skipping..."
        return 0
    fi

    log_info "Running code analysis..."

    if ! stcode -f "$st_file" -c "$corpus_dir" -o "$output_dir" ; then
        log_error "Code analysis failed"
        return 1
    fi

    log_info "Code analysis completed successfully"
}

# Function to build the fuzzer
run_build() {
    local st_file="$1"
    local harness_file="$2"
    local executable_name="$3"
    local build_dir="$4"

    log_info "Starting build process..."

    # Copy required source files to build directory
    for file_name in "${REQUIRED_SOURCE_FILES[@]}"; do
        local source_file="$REQUIRED_DIR/$file_name"
        if [ -f "$source_file" ]; then
            cp "$source_file" "$build_dir/"
            log_info "Copied source file $source_file to build/ directory"
        else
            log_error "Required source file not found: $source_file"
            exit 1
        fi
    done

    # Copy required header files to build directory
    for file_name in "${REQUIRED_HEADER_FILES[@]}"; do
        local header_file="$REQUIRED_DIR/$file_name"
        if [ -f "$header_file" ]; then
            cp "$header_file" "$build_dir/"
            log_info "Copied header file $header_file to build/ directory"
        else
            log_error "Required header file not found: $header_file"
            exit 1
        fi
    done

    # Copy ST file and harness file to build directory
    cp "$st_file" "$build_dir/"
    log_info "Copied ST file to build/ directory"
    cp "$harness_file" "$build_dir/"
    log_info "Copied harness file to build/ directory"

    # Get the original directory to return to later
    local original_dir="$(pwd)"

    # Change to build directory - ALL compilation happens here
    cd "$build_dir"

    log_info "Current directory: $(pwd)"
    log_info "Files in build directory:"
    ls -la

    # Get just the filename for the ST file (since we copied it to build dir)
    local st_filename="$(basename "$st_file")"

    # Generate IEC sources from ST file (now in build directory)
    log_info "Generating IEC sources from ST file: $st_filename"
    if ! "$IEC2C" "$st_filename" -I "$MATIEC_INCLUDE_PATH"; then
        log_error "Failed to generate IEC sources"
        cd "$original_dir"
        exit 1
    fi

    # Now compile only the C source files (not header files)
    # Combine generated C files and required C source files
    local all_sources=("${GENERATED_FILES[@]}" "${REQUIRED_SOURCE_FILES[@]}")
    local objects=()

    # Add include flags
    local include_flags="-I $MATIEC_C_INCLUDE_PATH"

    # Compile C source files only (all files are now in current directory)
    log_info "Compiling C source files..."
    for source in "${all_sources[@]}"; do
        # Only compile .c files
        if [[ "$source" == *.c ]] && [ -f "$source" ]; then
            local object_file="${source%.c}.o"
            log_info "Compiling $source -> $object_file"
            if ! $CC $CFLAGS $include_flags -c "$source" -o "$object_file"; then
                log_error "Failed to compile $source"
                cd "$original_dir"
                exit 1
            fi
            objects+=("$object_file")
        elif [ -f "$source" ]; then
            log_debug "Skipping non-C file: $source"
        else
            log_warn "Source file $source not found, skipping"
        fi
    done

    # Compile harness file (also copied to build directory)
    local harness_filename="$(basename "$harness_file")"
    if [ -f "$harness_filename" ]; then
        log_info "Compiling fuzzing harness: $harness_filename"
        if ! $CC $CFLAGS $include_flags -c "$harness_filename" -o harness.o; then
            log_error "Failed to compile harness"
            cd "$original_dir"
            exit 1
        fi
        objects+=("harness.o")
    fi

    # Compile set_plc_input if it exists
    if [ -f "set_plc_input.c" ]; then
        log_info "Compiling set_plc_input.c"
        if ! $CC $CFLAGS $include_flags -c "set_plc_input.c" -o set_plc_input.o; then
            log_error "Failed to compile set_plc_input.c"
            cd "$original_dir"
            exit 1
        fi
        objects+=("set_plc_input.o")
    fi

    # Link everything together
    log_info "Linking executable: $executable_name"
    if ! $CC "${objects[@]}" -o "$executable_name" $LDFLAGS; then
        log_error "Failed to link executable"
        cd "$original_dir"
        exit 1
    fi

    # Return to original directory
    cd "$original_dir"

    log_info "Build completed successfully!"
    log_info "Executable created: $build_dir/$executable_name"
}

# Function to setup AFL dictionary
setup_afl_dict() {
    local output_dir="$1"
    local dict_file="$2"

    log_info "Setting up AFL dictionary..."

    # Set AFL dictionary environment variable
    local dict_path="$output_dir/$dict_file"
    export AFL_LLVM_DICT2FILE="$dict_path"

    log_info "AFL dictionary will be generated at: $dict_path"

    # Create directory if it doesn't exist
    mkdir -p "$output_dir"
}

# Function to finalize build artifacts
finalize_artifacts() {
    local output_dir="$1"
    local executable_name="$2"

    log_info "Finalizing build artifacts..."

    # Check if executable was created in build directory
    if [ -f "$output_dir/$executable_name" ]; then
        log_info "Executable successfully created: $output_dir/$executable_name"
        # Make it executable if it isn't already
        chmod +x "$output_dir/$executable_name"
    else
        log_error "Executable not found: $output_dir/$executable_name"
        exit 1
    fi

    # Handle AFL dictionary if it was generated
    if [ -n "$AFL_LLVM_DICT2FILE" ] && [ -f "$AFL_LLVM_DICT2FILE" ]; then
        log_info "AFL dictionary generated: $AFL_LLVM_DICT2FILE"
    fi

    log_info "Build artifacts ready in: $output_dir"
}

# Main execution function
main() {
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd)"

    local original_dir="$(pwd)"

    log_info "Starting compile process..."
    log_debug "Script directory: $script_dir"
    log_debug "Original directory: $original_dir"

    # Parse arguments
    parse_args "$@"

    log_debug "ST file: $ST_FILE"
    log_debug "Harness file: $HARNESS_FILE"
    log_debug "Output directory: $OUTPUT_DIR"
    log_debug "Corpus directory: $CORPUS_DIR"
    log_debug "Executable name: $EXECUTABLE_NAME"

    # Check dependencies
    check_dependencies

    # Setup AFL dictionary
    setup_afl_dict "$OUTPUT_DIR" "$AFL_DICT_FILE"

    # Run code analysis
    if ! run_code_analysis "$ST_FILE" "$OUTPUT_DIR" "$CORPUS_DIR"; then
        log_error "Code analysis failed"
        exit 1
    fi

    # Run build (all compilation happens in build directory)
    if ! run_build "$ST_FILE" "$HARNESS_FILE" "$EXECUTABLE_NAME" "$OUTPUT_DIR"; then
        log_error "Build process failed"
        exit 1
    fi

    # Finalize artifacts
    finalize_artifacts "$OUTPUT_DIR" "$EXECUTABLE_NAME"

    log_info "Compile process completed successfully!"
    log_info "Output directory: $OUTPUT_DIR"

}

# Trap to ensure we return to original directory on exit
trap 'cd "$(pwd)" 2>/dev/null || true' EXIT

# Run main function with all arguments
main "$@"
